package rapid.service.client;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Answers;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import rapid.client.mapper.ClientReportOptionMapper;
import rapid.client.mapper.fetch.ClientReportOptionDataBundle;
import rapid.dto.client.ClientReportOptionDTO;
import rapid.model.client.AdminQueryList;
import rapid.model.client.C3FileTransfer;
import rapid.model.client.ClientReportOption;
import rapid.service.client.fetcher.ClientReportOptionDataFetcher;

import java.util.*;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ClientReportOptionServiceTest {

    // Allows dataFetcher.getAdminRepo().findAllReportIds()
    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
    ClientReportOptionDataFetcher dataFetcher;

    @Mock
    ClientReportOptionMapper optionMapper;

    @InjectMocks
    ClientReportOptionService service;

    // --- helpers -------------------------------------------------------------

    /** Plain DTO mock with NO stubbing (avoids UnnecessaryStubbing). */
    private ClientReportOptionDTO plainDto() {
        return mock(ClientReportOptionDTO.class);
    }

    /** DTO mock with clientId getter stubbed (only use in filtering tests). */
    private ClientReportOptionDTO dtoWithClientId(String clientId) {
        ClientReportOptionDTO dto = mock(ClientReportOptionDTO.class);
        when(dto.getClientId()).thenReturn(clientId);
        return dto;
    }

    private ClientReportOption option() { return mock(ClientReportOption.class); }

    private static <T> Map<Integer, T> map(Object... kv) {
        Map<Integer, T> m = new HashMap<>();
        for (int i = 0; i < kv.length; i += 2) {
            m.put((Integer) kv[i], (T) kv[i + 1]);
        }
        return m;
    }

    private static Map<Integer, List<ClientReportOption>> optionsMap(Object... kv) {
        Map<Integer, List<ClientReportOption>> m = new HashMap<>();
        for (int i = 0; i < kv.length; i += 2) {
            m.put((Integer) kv[i], (List<ClientReportOption>) kv[i + 1]);
        }
        return m;
    }

    // --- tests ---------------------------------------------------------------

    @Test
    @DisplayName("getAllWithDetails: flattens, enriches (admin+c3), maps to DTOs; skips null option lists")
    void getAllWithDetails_flattens_and_maps() {
        List<Integer> reportIds = List.of(10, 20, 30);

        AdminQueryList admin10 = mock(AdminQueryList.class);
        AdminQueryList admin20 = mock(AdminQueryList.class);
        AdminQueryList admin30 = mock(AdminQueryList.class);
        C3FileTransfer c3_10 = mock(C3FileTransfer.class);
        C3FileTransfer c3_20 = mock(C3FileTransfer.class);
        C3FileTransfer c3_30 = mock(C3FileTransfer.class);

        ClientReportOption optA = option(); // 10
        ClientReportOption optB = option(); // 10
        ClientReportOption optC = option(); // 30

        ClientReportOptionDataBundle bundle = new ClientReportOptionDataBundle(
                map(10, admin10, 20, admin20, 30, admin30),
                map(10, c3_10, 20, c3_20, 30, c3_30),
                optionsMap(
                        10, List.of(optA, optB),
                        20, null,                  // skipped
                        30, List.of(optC)
                )
        );

        when(dataFetcher.getAdminRepo().findAllReportIds()).thenReturn(reportIds);
        when(dataFetcher.fetchForReports(reportIds)).thenReturn(bundle);

        // Map to plain DTOs (no stubbing on getters to avoid UnnecessaryStubbing)
        ClientReportOptionDTO dtoA = plainDto();
        ClientReportOptionDTO dtoB = plainDto();
        ClientReportOptionDTO dtoC = plainDto();
        when(optionMapper.toDto(optA)).thenReturn(dtoA);
        when(optionMapper.toDto(optB)).thenReturn(dtoB);
        when(optionMapper.toDto(optC)).thenReturn(dtoC);

        List<ClientReportOptionDTO> result = service.getAllWithDetails();

        assertThat(result).containsExactlyInAnyOrder(dtoA, dtoB, dtoC);

        verify(dataFetcher.getAdminRepo()).findAllReportIds();
        verify(dataFetcher).fetchForReports(reportIds);
        verify(optionMapper).toDto(optA);
        verify(optionMapper).toDto(optB);
        verify(optionMapper).toDto(optC);

        verify(admin10, atLeastOnce()).setC3FileTransfer(c3_10);
        verify(admin30, atLeastOnce()).setC3FileTransfer(c3_30);
        verify(admin20, never()).setC3FileTransfer(any());
        verifyNoInteractions(c3_20);
    }

    @Nested
    @DisplayName("getAllWithDetailsByClient(clientId)")
    class ByClient {

        @Test
        @DisplayName("filters by trimmed clientId")
        void filters_matching_clientId() {
            List<Integer> reportIds = List.of(1, 2);
            AdminQueryList a1 = mock(AdminQueryList.class);
            AdminQueryList a2 = mock(AdminQueryList.class);
            C3FileTransfer c1 = mock(C3FileTransfer.class);
            C3FileTransfer c2 = mock(C3FileTransfer.class);
            ClientReportOption o1 = option(); // -> "1234"
            ClientReportOption o2 = option(); // -> "5678"
            ClientReportOption o3 = option(); // -> "1234"

            ClientReportOptionDataBundle bundle = new ClientReportOptionDataBundle(
                    map(1, a1, 2, a2),
                    map(1, c1, 2, c2),
                    optionsMap(
                            1, List.of(o1, o2),
                            2, List.of(o3)
                    )
            );

            when(dataFetcher.getAdminRepo().findAllReportIds()).thenReturn(reportIds);
            when(dataFetcher.fetchForReports(reportIds)).thenReturn(bundle);

            // Now we DO need clientId getter stubbing
            ClientReportOptionDTO d1 = dtoWithClientId("1234");
            ClientReportOptionDTO d2 = dtoWithClientId("5678");
            ClientReportOptionDTO d3 = dtoWithClientId("1234");
            when(optionMapper.toDto(o1)).thenReturn(d1);
            when(optionMapper.toDto(o2)).thenReturn(d2);
            when(optionMapper.toDto(o3)).thenReturn(d3);

            List<ClientReportOptionDTO> filtered = service.getAllWithDetailsByClient(" 1234 ");

            assertThat(filtered).containsExactlyInAnyOrder(d1, d3);
            assertThat(filtered).allMatch(x -> "1234".equals(x.getClientId()));
        }

        @Test
        @DisplayName("fast path: null/blank clientId -> empty and no fetch")
        void returns_empty_on_null_or_blank() {
            assertThat(service.getAllWithDetailsByClient(null)).isEmpty();
            assertThat(service.getAllWithDetailsByClient("")).isEmpty();
            assertThat(service.getAllWithDetailsByClient("   ")).isEmpty();
            verifyNoInteractions(dataFetcher, optionMapper);
        }

        @Test
        @DisplayName("ignores DTOs with null clientId when filtering")
        void ignores_null_clientId_in_dtos() {
            List<Integer> reportIds = List.of(9);
            AdminQueryList admin = mock(AdminQueryList.class);
            C3FileTransfer c3 = mock(C3FileTransfer.class);
            ClientReportOption o1 = option(); // -> "1234"
            ClientReportOption o2 = option(); // -> null clientId

            ClientReportOptionDataBundle bundle = new ClientReportOptionDataBundle(
                    map(9, admin),
                    map(9, c3),
                    optionsMap(9, List.of(o1, o2))
            );

            when(dataFetcher.getAdminRepo().findAllReportIds()).thenReturn(reportIds);
            when(dataFetcher.fetchForReports(reportIds)).thenReturn(bundle);

            ClientReportOptionDTO d1 = dtoWithClientId("1234");
            ClientReportOptionDTO dNull = dtoWithClientId(null);
            when(optionMapper.toDto(o1)).thenReturn(d1);
            when(optionMapper.toDto(o2)).thenReturn(dNull);

            List<ClientReportOptionDTO> filtered = service.getAllWithDetailsByClient("1234");

            assertThat(filtered).containsExactly(d1);
        }
    }
}
