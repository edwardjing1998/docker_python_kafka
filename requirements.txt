package rapid.service.client;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.Mockito;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import rapid.client.web.ClientReportOptionController;
import rapid.dto.client.ClientReportOptionDTO;
import rapid.service.client.ClientReportOptionService;

import java.util.List;

import static org.hamcrest.Matchers.hasSize;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

class ClientReportOptionControllerTest {

    private MockMvc mockMvc;
    private ClientReportOptionService service;

    // If your DTO has a no-arg constructor, prefer creating a real instance:
    // private ClientReportOptionDTO dto() { return new ClientReportOptionDTO(); }
    // Using a mock is fine here since we don't assert fields.
    private ClientReportOptionDTO dto() {
        return Mockito.mock(ClientReportOptionDTO.class);
    }

    @BeforeEach
    void setup() {
        service = Mockito.mock(ClientReportOptionService.class);
        ClientReportOptionController controller = new ClientReportOptionController(service);

        mockMvc = MockMvcBuilders.standaloneSetup(controller)
                // If you have a @ControllerAdvice for errors, add it:
                // .setControllerAdvice(new GlobalExceptionHandler())
                .build();
    }

    @Test
    @DisplayName("GET /api/client/report-option returns 200 with list")
    void getAllReports_ok() throws Exception {
        when(service.getAllWithDetails()).thenReturn(List.of(dto(), dto()));

        mockMvc.perform(get("/api/client/report-option").accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$", hasSize(2)));

        verify(service, times(1)).getAllWithDetails();
        verifyNoMoreInteractions(service);
    }

    @Test
    @DisplayName("GET /api/client/{clientId}/report-option returns 200 for 4-digit id and calls service")
    void getReportsByClient_validId_ok() throws Exception {
        String clientId = "1234";
        when(service.getAllWithDetailsByClient(clientId)).thenReturn(List.of(dto()));

        mockMvc.perform(get("/api/client/{clientId}/report-option", clientId)
                        .accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$", hasSize(1)));

        verify(service, times(1)).getAllWithDetailsByClient(eq(clientId));
        verifyNoMoreInteractions(service);
    }

    @ParameterizedTest(name = "Invalid clientId \"{0}\" should return 400 and not call service")
    @ValueSource(strings = {"123", "12345", "12a4", "ABCD", "", "  ", "000", "12-4"})
    void getReportsByClient_invalidId_badRequest(String badId) throws Exception {
        mockMvc.perform(get("/api/client/{clientId}/report-option", badId)
                        .accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isBadRequest());

        verifyNoInteractions(service);
    }
}
